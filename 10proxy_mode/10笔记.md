10 AOP 

一种设计模式:代理模式(23种设计模式之一)
代理模式是Spring 面向切面编程(Aspect Oriented Programming,AOP)的底层

代理模式的分类:
· 静态代理
· 动态代理

共同的接口                              租房

真实的人(需要房子的人)    代理的角色(中介)    真实的角色(房东)

10.1 静态代理
角色分析:
·抽象角色:一般会使用接口或者抽象类来解决(租房)
·真实的角色:被代理的角色(房东)
·代理角色:代理真实的角色,代理真实角色后,一般会做一些附属操作(中介)
代理去拿一个房东,在代理类中声明一个房东(组合),而不是去继承房东类
·客户:访问代理对象的人(需要房子的人)
(只能在测试test目录中使用@Test注解)

代理模式的好处:
· 可以使真是角色(房东)的操作更加纯粹,解耦。不用关注一些公共的操作
· 公共操作交给代理角色, 实现了业务的分工
· 公共业务发生拓展的时候, 方便集中管理

缺点:
一个真是角色就会产生一个代理角色
代码量翻倍, 开发效率变低

代码步骤:
1.定义抽象类或者接口
2.定义真实角色(房东)实现接口
3.定义代理角色,代理真实角色,也实现接口
4.客户端访问代理角色

10.2 加深理解
psvm 快速打出main函数
sout 快速打出print函数
设计增删改查接口
实现增删改查类
需求:在每个操作的前面输出日志

改动原有的业务代码在公司中是大忌!

面向对象有七大原则!

AOP:
        dao
                            AOP的实现机制
纵      service   ------------>      <====== Log:### 横向开发 ###
向
开      controller
发
         前端

10.3 动态代理(反射)
· 动态代理和静态代理的角色是一样的
· 动态代理的代理类是动态生成的, 不是直接写好的
· 动态代理实现机制分为两大类:
-- 基于接口的动态代理 --- JDK 动态代理 [课程使用这一种]
-- 基于类的动态代理 --- cglib
-- 基于java字节码实现 --- javassist

需要了解两个类: Proxy-代理 和 InvocationHandler-调用处理程序
·InvocationHandler 是java.lang.reflect反射包下的一个由代理实例的调用处理程序实现的接口
每一个代理实例都有一个关联的调用处理程序,
当在实例上调用方法时, 方法调用将被编码并分派到其调用处理程序的invoke方法
详细参考api文档 InvocationHandler d:idea workspace下面
·Proxy 是java.lang.reflect反射包下的一个类,
Proxy提供了用于创建对象的静态方法，这些对象充当接口实例但允许自定义方法调用。

动态代理的好处:
· 可以使真是角色(房东)的操作更加纯粹,解耦。不用关注一些公共的操作
· 公共操作交给代理角色, 实现了业务的分工
· 公共业务发生拓展的时候, 方便集中管理
· 一个动态代理类代理的是一个特定的接口,对应的是一类业务(复用成本极低)
· 一个动态代理类可以代理多个该接口的实现类, 只要该类实现了该接口
